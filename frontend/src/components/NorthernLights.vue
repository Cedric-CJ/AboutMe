<template>
  <canvas ref="canvas" class="canvas"></canvas>
</template>
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'
const canvas = ref(null)
let ctx = null
let animationFrameId
let time = 0
let primaryColorHSL = { h: 200, s: 100, l: 60 }
let waterColor = 'rgba(0,50,100,0.8)'
const MAX_AURORA_LINES = 2
const auroraLines = []
const stars = []
const shootingStars = []
let baseMirrorLine = 0

function hexToHsl(hex){ let c=hex.replace('#',''); if(c.length===3)c=c.split('').map(x=>x+x).join(''); const r=parseInt(c.slice(0,2),16)/255,g=parseInt(c.slice(2,4),16)/255,b=parseInt(c.slice(4,6),16)/255; const max=Math.max(r,g,b),min=Math.min(r,g,b); let h=0,s=0; const d=max-min; const l=(max+min)/2; if(d!==0){ s=l>0.5? d/(2-max-min): d/(max+min); switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;default:h=(r-g)/d+4;} h*=60;} return {h:Math.round(h),s:Math.round(s*100),l:Math.round(l*100)} }
function loadPrimaryColor(){ const css=getComputedStyle(document.documentElement).getPropertyValue('--accent-raw').trim(); if(css && css.startsWith('#')) primaryColorHSL=hexToHsl(css) }
function initCanvas(){ if(!canvas.value) return; canvas.value.width=window.innerWidth; canvas.value.height=window.innerHeight; ctx=canvas.value.getContext('2d'); baseMirrorLine=canvas.value.height*0.4 }
function getMirrorLine(){ return baseMirrorLine + 5*Math.sin(time*0.5) }
function createAuroraLine(){ const dir=Math.random()<0.5?'left':'right'; const spawnOffset=200+Math.random()*400; const exitOffset=200+Math.random()*400; const spawnX=dir==='left'?-spawnOffset:canvas.value.width+spawnOffset; const speedX=dir==='left'?0.3+Math.random()*0.9:-(0.3+Math.random()*0.9); const exitX=dir==='left'?canvas.value.width+exitOffset:-exitOffset; let startY; let attempts=0; do{ startY=canvas.value.height*(0.05+Math.random()*0.25); attempts++; } while(auroraLines.some(l=>l.dir===dir && Math.abs(l.y-startY)<120) && attempts<10); const hueOffset=(Math.random()-0.5)*50; return { x:spawnX,y:startY,dir,speedX,spawnX,exitX,baseLength:500+Math.random()*300,baseAmplitude:5+Math.random()*5,baseBandThickness:60+Math.random()*30,cycles:1+Math.random()*2,phase:Math.random()*2*Math.PI,hueOffset,hue:primaryColorHSL.h+hueOffset,saturation:primaryColorHSL.s,lightness:primaryColorHSL.l,swayAmplitude:5+Math.random()*5,swayPhase:Math.random()*2*Math.PI,depthShift:20 } }
function updatePolarLights(){ while(auroraLines.length<MAX_AURORA_LINES) auroraLines.push(createAuroraLine()); for(let i=0;i<auroraLines.length;i++){ const line=auroraLines[i]; line.hue=primaryColorHSL.h+line.hueOffset; line.x += line.speedX; const f = line.dir==='left' ? (line.x-line.spawnX)/(line.exitX-line.spawnX) : (line.spawnX-line.x)/(line.spawnX-line.exitX); if(f<=0||f>=1){ auroraLines[i]=createAuroraLine(); continue; } const scale=4*f*(1-f); const currentLength=line.baseLength*scale; const currentAmplitude=line.baseAmplitude*scale; const currentBandThickness=line.baseBandThickness*scale; const points=[]; const segments=40; const swayOffset=line.swayAmplitude*Math.sin(time+line.swayPhase); for(let j=0;j<=segments;j++){ const t=j/segments; const baseX=line.x + t*currentLength; const offset=currentAmplitude*Math.sin(2*Math.PI*(line.cycles*t+line.phase+time)); points.push({x:baseX+swayOffset,y:line.y+offset,t}) } drawAurora(points,line,currentBandThickness,scale); drawAuroraReflection(points,line,currentBandThickness,scale) } }
function drawAurora(points,line,bandThickness,scale){ ctx.save(); ctx.filter='blur(3px)'; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y); for(let j=1;j<points.length;j++) ctx.lineTo(points[j].x,points[j].y); for(let j=points.length-1;j>=0;j--){ const shift=line.depthShift*(1-points[j].t); ctx.lineTo(points[j].x-shift,points[j].y-bandThickness) } ctx.closePath(); const g=ctx.createLinearGradient(0,line.y,0,line.y-bandThickness); g.addColorStop(0,`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, ${0.8*scale})`); g.addColorStop(0.5,`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, ${0.4*scale})`); g.addColorStop(1,`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, 0)`); ctx.fillStyle=g; ctx.shadowColor=`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, ${0.6*scale})`; ctx.shadowBlur=40; ctx.fill(); ctx.restore() }
function drawAuroraReflection(points,line,bandThickness,scale){ const m=getMirrorLine(); ctx.save(); ctx.beginPath(); ctx.rect(0,m,canvas.value.width,canvas.value.height-m); ctx.clip(); ctx.translate(0,2*m); ctx.scale(1,-0.67); ctx.globalAlpha=0.5; const wave=x=>5*Math.sin(x/100+time); ctx.filter='blur(3px)'; ctx.lineJoin='round'; ctx.lineCap='round'; ctx.beginPath(); ctx.moveTo(points[0].x,points[0].y+wave(points[0].x)); for(let j=1;j<points.length;j++) ctx.lineTo(points[j].x,points[j].y+wave(points[j].x)); for(let j=points.length-1;j>=0;j--){ const shift=line.depthShift*(1-points[j].t); ctx.lineTo(points[j].x-shift,points[j].y-bandThickness+wave(points[j].x-shift)) } ctx.closePath(); const g=ctx.createLinearGradient(0,line.y,0,line.y-bandThickness); g.addColorStop(0,`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, ${0.8*scale})`); g.addColorStop(0.5,`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, ${0.4*scale})`); g.addColorStop(1,`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, 0)`); ctx.fillStyle=g; ctx.shadowColor=`hsla(${line.hue}, ${line.saturation}%, ${line.lightness}%, ${0.6*scale})`; ctx.shadowBlur=40; ctx.fill(); ctx.restore() }
function initStars(){ const num=100; for(let i=0;i<num;i++){ const s={ x:Math.random()*canvas.value.width, y:Math.random()*baseMirrorLine, baseRadius:Math.random()*1.5, radius:0, baseAlpha:0.5+Math.random()*0.5, twinkleSpeed:0.001+Math.random()*0.002, phase:Math.random()*2*Math.PI }; s.radius=s.baseRadius; stars.push(s) } }
function drawStars(){ stars.forEach(star=>{ const newAlpha=star.baseAlpha+Math.sin(performance.now()*star.twinkleSpeed+star.phase); const alpha=Math.max(0.3,Math.min(newAlpha,star.baseAlpha+1)); ctx.beginPath(); ctx.arc(star.x,star.y,star.radius,0,2*Math.PI); ctx.fillStyle=`rgba(255,255,255,${alpha})`; ctx.fill() }) }
function drawStarsReflection(){ const m=getMirrorLine(); ctx.save(); ctx.beginPath(); ctx.rect(0,m,canvas.value.width,canvas.value.height-m); ctx.clip(); ctx.translate(0,2*m); ctx.scale(1,-0.67); ctx.globalAlpha=0.6; const wave=x=>5*Math.sin(x/100+time); stars.forEach(star=>{ ctx.beginPath(); ctx.arc(star.x, star.y+wave(star.x), star.radius, 0, 2*Math.PI); ctx.fillStyle='rgba(255,255,255,0.7)'; ctx.fill() }); ctx.restore() }
function spawnShootingStar(){ shootingStars.push({ x:Math.random()*canvas.value.width, y:Math.random()*(baseMirrorLine*0.8), length:80+Math.random()*50, speed:5+Math.random()*3, angle:Math.PI/4, alpha:1 }) }
function updateShootingStars(){ for(let i=shootingStars.length-1;i>=0;i--){ const s=shootingStars[i]; s.x+=Math.cos(s.angle)*s.speed; s.y+=Math.sin(s.angle)*s.speed; s.alpha-=0.01; if(s.alpha<=0 || s.y>baseMirrorLine){ shootingStars.splice(i,1) } else { ctx.beginPath(); ctx.moveTo(s.x,s.y); ctx.lineTo(s.x-Math.cos(s.angle)*s.length, s.y-Math.sin(s.angle)*s.length); ctx.strokeStyle=`rgba(255,255,255,${s.alpha})`; ctx.lineWidth=2; ctx.stroke() } } if(Math.random()<0.002) spawnShootingStar() }
function drawMoon(){ const x=canvas.value.width*0.8, y=canvas.value.height*0.2, r=60; ctx.save(); ctx.shadowBlur=30; ctx.shadowColor='rgba(255,255,255,0.6)'; ctx.beginPath(); ctx.arc(x,y,r,0,2*Math.PI); const grad=ctx.createRadialGradient(x,y,r*.2,x,y,r); grad.addColorStop(0,'rgba(255,255,255,1)'); grad.addColorStop(0.7,'rgba(220,220,220,0.9)'); grad.addColorStop(1,'rgba(180,180,180,0.8)'); ctx.fillStyle=grad; ctx.fill(); ctx.shadowBlur=0; ctx.globalCompositeOperation='multiply'; ctx.beginPath(); ctx.arc(x-10,y-10,r*.95,0,2*Math.PI); ctx.fillStyle='rgba(0,0,0,0.15)'; ctx.fill(); ctx.globalCompositeOperation='source-over'; ctx.restore() }
function drawMoonReflection(){ const m=getMirrorLine(); const x=canvas.value.width*0.8, y=canvas.value.height*0.2, r=60; ctx.save(); ctx.beginPath(); ctx.rect(0,m,canvas.value.width,canvas.value.height-m); ctx.clip(); ctx.translate(0,2*m); ctx.scale(1,-0.67); ctx.globalAlpha=0.4; ctx.beginPath(); ctx.arc(x,y,r,0,2*Math.PI); const grad=ctx.createRadialGradient(x,y,r*.2,x,y,r); grad.addColorStop(0,'rgba(255,255,255,0.5)'); grad.addColorStop(0.7,'rgba(220,220,220,0.4)'); grad.addColorStop(1,'rgba(180,180,180,0.3)'); ctx.fillStyle=grad; ctx.fill(); ctx.restore() }
function drawReflectionOverlay(){ const m=getMirrorLine(); ctx.save(); ctx.filter='blur(3px)'; ctx.globalAlpha=0.3; ctx.fillStyle=waterColor; ctx.fillRect(0,m,canvas.value.width,canvas.value.height-m); ctx.restore() }
function update(){ time+=0.005; loadPrimaryColor(); ctx.clearRect(0,0,canvas.value.width,canvas.value.height); drawMoon(); drawStars(); drawStarsReflection(); updatePolarLights(); updateShootingStars(); drawMoonReflection(); drawReflectionOverlay(); animationFrameId=requestAnimationFrame(update) }
onMounted(()=>{ initCanvas(); loadPrimaryColor(); initStars(); window.addEventListener('resize', initCanvas); update() })
onUnmounted(()=>{ window.removeEventListener('resize', initCanvas); cancelAnimationFrame(animationFrameId) })
</script>
<style scoped>
.canvas{ position:fixed; top:0; left:0; width:100%; height:100vh; background:#000; pointer-events:none; z-index:-1 }
</style>
